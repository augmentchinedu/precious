# AuditLogger Module Design

## 1. Introduction

This document provides the detailed design for the `AuditLogger` module. It is a key component of the Execution Layer, responsible for creating an immutable, structured audit trail of all agent file actions. The design is based on the task assigned in `execution-layer-impl-plan.md` and fulfills the logging requirements outlined in `execution-layer-spec.md`.

## 2. Core Requirements

As specified by the Developer Operator, Roni, the audit trail must be:

-   **Location:** A dedicated log file at `logs/execution-layer.log`.
-   **Format:** JSON Lines (JSONL), where each line is a complete JSON object representing a single log entry. This format is highly machine-parseable.
-   **Schema:** Each log entry must conform to the following structure:
    ```json
    {
      "timestamp": "ISO-8601-datetime",
      "agent": "AgentName",
      "action": {
        "type": "create" | "append",
        "path": "path/to/file.md"
      },
      "status": "success" | "failure",
      "details": {
        "commit_hash": "...",
        "error_message": "..."
      }
    }
    ```

## 3. Technology Selection

-   **Library:** As recommended in the implementation plan, `pino` is the selected logging library. Its high performance and native support for JSON output make it ideal for this task. It operates asynchronously, ensuring that logging does not block the main execution thread of the Execution Layer.

## 4. Module API and Interface

The `AuditLogger` will be implemented as a class or a factory function that exposes a single, simple interface.

### 4.1. Initialization

-   The module will be initialized once by the `ExecutionController`.
-   During initialization, it will:
    1.  Confirm the existence of the `logs/` directory. If it does not exist, it will be created.
    2.  Instantiate a `pino` logger configured to write to the `logs/execution-layer.log` file.

### 4.2. `logAction(entry)` Method

-   **Description:** The sole method for writing to the audit trail. It is designed to be fire-and-forget from the perspective of the caller (`ExecutionController`).
-   **Input:**
    -   `entry`: A JavaScript object that strictly conforms to the log entry schema defined in Section 2. The responsibility for constructing this object lies with the `ExecutionController`, not the logger.
-   **Action:**
    1.  The method will take the `entry` object.
    2.  It will use the configured `pino` instance to write the object as a single line to the log file.
    3.  The timestamp will be automatically generated by the logger at the moment of writing to ensure accuracy, overriding any timestamp in the input object.

## 5. Error Handling

System stability requires that a failure in the logging subsystem does not cause a failure in the primary `FILE_ACTION` workflow.

-   **File System Errors:** If `pino` encounters an error while writing to `logs/execution-layer.log` (e.g., due to disk space or permissions issues), this error will not be thrown up to the `ExecutionController`.
-   **Fallback Logging:** Instead, the logger will attempt to write the error message and the original log entry to the standard error stream (`stderr`). This ensures that critical failure information is not lost, even if the primary log file is unavailable.
-   **No Impact on Agent Action:** The success or failure of a `FILE_ACTION` operation must not depend on the success or failure of the `AuditLogger`.

## 6. Future Considerations: Log Management

While not part of the initial implementation, a production-grade system requires a log management strategy. The current design of appending to a single file is sufficient for Phase 1, but future enhancements should include:

-   **Log Rotation:** A mechanism (e.g., an external tool like `logrotate` or a built-in library feature) to archive log files based on size or date, preventing the log file from growing indefinitely.
-   **Log Analysis:** The structured JSONL format is chosen specifically to enable future automated analysis, monitoring, and alerting based on log content.
